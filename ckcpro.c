
/* WARNING -- This C source program generated by Wart preprocessor. */
/* Do not edit this file; edit the Wart-format source file instead, */
/* and then run it through Wart to produce a new C source file.     */

/* Wart Version Info: */
char *wartv = "Wart Version 1A(006) Jan 1989";

char *protv = "C-Kermit Protocol Module 5A(036), 27 Jan 90"; /* -*-C-*- */

/* C K C P R O  -- C-Kermit Protocol Module, in Wart preprocessor notation. */
/*
 Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),
 Columbia University Center for Computing Activities.
 First released January 1985.
 Copyright (C) 1985, 1990, Trustees of Columbia University in the City of New 
 York.  Permission is granted to any individual or institution to use, copy, or
 redistribute this software so long as it is not sold for profit, provided this
 copyright notice is retained. 
*/
#include "ckcdeb.h"
#include "ckcasc.h"
#include "ckcker.h"
/*
 Note -- This file may also be preprocessed by the Unix Lex program, but 
 you must indent the above #include statements before using Lex, and then
 restore them to the left margin in the resulting C program before compilation.
 Also, the invocation of the "wart()" function below must be replaced by an
 invocation  of the "yylex()" function.  It might also be necessary to remove
 comments in the %%...%% section.
*/

/* State definitions for Wart (or Lex) */
#define ipkt 1
#define rfile 2
#define rattr 3
#define rdata 4
#define ssinit 5
#define ssfile 6
#define ssattr 7
#define ssdata 8
#define sseof 9
#define sseot 10
#define serve 11
#define generic 12
#define get 13
#define rgen 14

/* External C-Kermit variable declarations */
  extern char sstate, *versio, *srvtxt, *cmarg, *cmarg2, *rpar();
  extern char *data, encbuf[], filnam[], srvcmd[], ttname[], *srvptr;
  extern int timint, nfils, hcflg, xflg, speed, flow, mdmtyp, network;
  extern int cxseen, czseen, server, local, displa, bctu, bctr, quiet;
  extern int tsecs, parity, backgrd, nakstate, atcapu, wslotsn, winlo;
  extern int wslots, success, cmdlvl, rprintf;
  extern int putsrv(), puttrm(), putfil(), errpkt();
  extern char *DIRCMD, *DELCMD, *TYPCMD, *SPACMD, *SPACM2, *WHOCMD;
  extern char *rdatap;
  extern struct zattr iattr;

/* Flags for the ENABLE and DISABLE commands */
extern int en_cwd, en_del, en_dir, en_fin, 
   en_get, en_hos, en_sen, en_spa, en_set, en_typ, en_who;

/* Local variables */
  static char vstate = 0;  		/* Saved State   */
  static char vcmd = 0;    		/* Saved Command */
  int x;				/* General-purpose integer */
  char *s;				/* General-purpose string pointer */

/* Macros - Note, BEGIN is predefined by Wart (and Lex) as "state = ", */
/* BEGIN is NOT a GOTO! */
#define TINIT  if (tinit() < 0) return(-9)
#define SERVE  TINIT; nakstate = 1; BEGIN serve
#define RESUME if (server) { SERVE; } else { sleep(2); return(0); }
#define QUIT x=quiet; quiet=1; clsif(); clsof(1); tsecs=gtimer(); quiet=x; \
 return(1)


#define BEGIN state =

int state = 0;

wart()
{
    int c,actno;
    extern CHAR tbl[];
    while (1) {
	c = input();
	if ((actno = tbl[c + state*128]) != -1)
	    switch(actno) {
case 1:
    { TINIT;				/* Do Send command */
    if (sinit()) BEGIN ssinit;
       else RESUME; }
    break;
case 2:
    { TINIT; nakstate = 1; BEGIN get; }
    break;
case 3:
    { TINIT; vstate = get;  vcmd = 0;   sipkt('I'); BEGIN ipkt; }
    break;
case 4:
    { TINIT; vstate = rgen; vcmd = 'C'; sipkt('I'); BEGIN ipkt; }
    break;
case 5:
    { TINIT; vstate = rgen; vcmd = 'G'; sipkt('I'); BEGIN ipkt; }
    break;
case 6:
    { sleep(1); SERVE; }
    break;
case 7:
    { errpkt("User cancelled transaction"); /* "ABEND" -- Tell other side. */
    success = 0;
    return(0); }
    break;
case 8:
    {			/* Receive Send-Init packet. */
    nakstate = 1;			/* Can send NAKs from here. */
    rinit(rdatap);			/* Set parameters */
    bctu = bctr;			/* Switch to agreed-upon block check */
    resetc();				/* Reset counters */
    rtimer();				/* Reset timer */
    BEGIN rfile;			/* Go into receive-file state */
}
    break;
case 9:
    {				/* Get ack for I-packet */
    spar(rdatap);			/* Set parameters */
    getsbuf(winlo = 0);			/* Set window-low back to zero */
    if (vcmd) {				/* If sending a generic command */
	scmd(vcmd,cmarg);		/* Do that */
	vcmd = 0;			/* and then un-remember it. */
    } else if (vstate == get) srinit();	/* If sending GET command, do that */
    winlo = 0;				/* Again! */
    nakstate = 1;			/* Can send NAKs from here. */
    BEGIN vstate;			/* Switch to desired state */
}
    break;
case 10:
    {				/* Ignore Error reply to I packet */
    if (vcmd) {				/* in case other Kermit doesn't */
	scmd(vcmd,cmarg);		/* understand I-packets. */
	vcmd = 0;			/* Otherwise act as above... */
    }
    if (vstate == get) srinit();
    BEGIN vstate;
}
    break;
case 11:
    {		/* Resend of previous I-pkt ACK, same seq number! */
    srinit();
}
    break;
case 12:
    {				/* Get I-packet */
    spar(rdatap);			/* Set parameters from it */
    ack1(rpar());			/* Respond with our own parameters */
    pktinit();				/* Reinitialize packet numbers */
}
    break;
case 13:
    {				/* Get Receive-Init */
    srvptr = srvcmd;			/* Point to server command buffer */
    decode(rdatap,putsrv);		/* Decode the GET command into it */
    cmarg = srvcmd;
    nfils = -1;				/* Initialize number of files */
    nakstate = 0;			/* Now I'm the sender! */
    if (sinit())			/* Send Send-Init */
      BEGIN ssinit;			/* If successful, switch state */
    else { SERVE; }			/* Else back to server command wait */
}
    break;
case 14:
    {				/* Generic server command */
    srvptr = srvcmd;			/* Point to command buffer */
    decode(rdatap,putsrv);		/* Decode packet data into it */
    putsrv('\0');			/* Insert a couple nulls */
    putsrv('\0');			/* for termination */
    sstate = srvcmd[0];			/* Set requested start state */
    nakstate = 0;			/* Now I'm the sender. */
    BEGIN generic;			/* Switch to generic command state */
}
    break;
case 15:
    {				/* Receive Host command */
    srvptr = srvcmd;			/* Point to command buffer */
    decode(rdatap,putsrv);		/* Decode command packet into it */
    putsrv('\0');			/* Null-terminate */
    nakstate = 0;			/* Now sending, not receiving */
    if (syscmd(srvcmd,""))		/* Try to execute the command */
      BEGIN ssinit;			/* If OK, send back its output */
    else {				/* Otherwise */
	errpkt("Can't do system command"); /* report error */
	SERVE;				/* & go back to server command wait */
    }
}
    break;
case 16:
    { success = 0; QUIT; }
    break;
case 17:
    {				/* Any other command in this state */
    errpkt("Unimplemented server function"); /* we don't know about */
    SERVE;				/* back to server command wait */
}
    break;
case 18:
    {				/* Got REMOTE CWD command */
    if (!en_hos) {
	errpkt("REMOTE CD disabled");
	SERVE;
    } else {
	if (!cwd(srvcmd+1)) errpkt("Can't change directory"); /* Try it */
	SERVE;				/* Back to server command wait */
    }
}
    break;
case 19:
    {				/* REMOTE DIRECTORY command */
    if (!en_dir) {
	errpkt("REMOTE DIRECTORY disabled");    
	SERVE;
    } else {
	if (syscmd(DIRCMD,srvcmd+2))	/* If it can be done */
	  BEGIN ssinit;			/* send the results back */
	else {				/* otherwise */
	    errpkt("Can't list directory"); /* report failure */
	    SERVE;			/* & return to server command wait */
	}
    }
}
    break;
case 20:
    {				/* REMOTE DELETE (Erase) command */
    if (!en_del) {
	errpkt("REMOTE DELETE disabled");    
	SERVE;
    } else {
	if (syscmd(DELCMD,srvcmd+2))	/* Try to do it */
	  BEGIN ssinit;			/* If OK send results back */
	else {				/* otherwise */
	    errpkt("Can't remove file"); /* report failure */
	    SERVE;			/* & return to server command wait */
	}
    }
}
    break;
case 21:
    {				/* FINISH */
    if (!en_fin) {
	errpkt("FINISH disabled");    
	SERVE;
    } else {
	ack();				/* Acknowledge */
	screen(SCR_TC,0,0l,"");		/* Display */
	return(0);			/* Done */
    }
}
    break;
case 22:
    {				/* BYE (LOGOUT) */
    if (!en_fin) {
	errpkt("BYE disabled");    
	SERVE;
    } else {
	ack();				/* Acknowledge */
	ttres();			/* Reset the terminal */
	screen(SCR_TC,0,0l,"");		/* Display */
	return(zkself());		/* Try to log self out */
    }
}
    break;
case 23:
    {				/* REMOTE HELP */
    if (sndhlp()) BEGIN ssinit;		/* Try to send it */
    else {				/* If not ok, */
	errpkt("Can't send help");	/* send error message instead */
	SERVE;				/* and return to server command wait */
    }
}
    break;
case 24:
    {				/* REMOTE SET */
    if (!en_set) {
	errpkt("REMOTE SET disabled");
	SERVE;
    } else {
	if (remset(srvcmd+1))		/* Try to do what they ask */
	  ack();			/* If OK, then acknowledge */
	else				/* Otherwise */
	  errpkt("Unknown REMOTE SET parameter"); /* give error message */
	SERVE;				/* Return to server command wait */
    }
}
    break;
case 25:
    {				/* REMOTE TYPE */
    if (!en_typ) {
	errpkt("REMOTE TYPE disabled");
	SERVE;
    } else {
	if (syscmd(TYPCMD,srvcmd+2))	/* Try */
	  BEGIN ssinit;			/* OK */
	else {				/* not OK */
	    errpkt("Can't type file");	/* give error message */
	    SERVE;			/* wait for next server command */
	}
    }
}
    break;
case 26:
    {				/* REMOTE SPACE */
    if (!en_spa) {
	errpkt("REMOTE SPACE disabled");
	SERVE;
    } else {
	x = *(srvcmd+1);		/* Get area to check */
	x = ((x == '\0') || (x == SP));
	x = (x ? syscmd(SPACMD,"") : syscmd(SPACM2,srvcmd+2));
	if (x)				/* If we got the info */
	  BEGIN ssinit;			/* send it */
	else {				/* otherwise */
	    errpkt("Can't check space");	/* send error message */
	    SERVE;			/* and await next server command */
	}
    }
}
    break;
case 27:
    {				/* REMOTE WHO */
    if (!en_who) {
	errpkt("REMOTE WHO disabled");
	SERVE;
    } else {
	if (syscmd(WHOCMD,srvcmd+2))	/* The now-familiar scenario... */
	  BEGIN ssinit;
	else {
	    errpkt("Can't do who command");
	    SERVE;
	}
    }
}
    break;
case 28:
    { success = 0; QUIT; }
    break;
case 29:
    {				/* Anything else in this state... */
    errpkt("Unimplemented REMOTE command"); /* Complain */
    SERVE;				/* and return to server command wait */
}
    break;
case 30:
    {				/* Short-Form reply */
    decode(rdatap,puttrm);		/* in ACK Data field */
    RESUME;
}
    break;
case 31:
    {				/* File header */
    xflg = 0;				/* Not screen data */
    rcvfil(filnam);			/* Figure out local filename */
    encstr(filnam);			/* Encode it */
    ack1(encbuf);			/* Send it back in ACK */
    initattr(&iattr);			/* Clear file attribute structure */
    window(wslotsn);			/* allocate negotiated window slots */
    BEGIN rattr;			/* Now expect Attribute packets */
}
    break;
case 32:
    {				/* X-packet instead of file header */
    xflg = 1;				/* Screen data */
    ack();				/* Acknowledge the X-packet */
    initattr(&iattr);			/* Initialize attribute structure */
    window(wslotsn);			/* allocate negotiated window slots */
    BEGIN rattr;			/* Expect Attribute packets */
}
    break;
case 33:
    {				/* Attribute packet */
    if (gattr(rdatap,&iattr) == 0)	/* Read into attribute structure */
      ack();				/* If OK, acknowledge */
    else
      ack1(iattr.reply.val);		/* refuse to accept the file */
}
    break;
case 34:
    {				/* First data packet */
    if (xflg)				/* If screen data */
      x = opent(&iattr);		/* "open" the screen */
    else				/* otherwise */
      x = opena(filnam,&iattr);		/* open the file, with attributes */
    if (x) {				/* If file was opened ok */
	if (decode(rdatap,putfil) < 0) { /* decode first data packet */
	    errpkt("Error writing data");
	    RESUME;
	}
	ack();				/* acknowledge it */
	BEGIN rdata;			/* and switch to receive-data state */
    } else {				/* otherwise */
	errpkt("Can't open file");	/* send error message */
	RESUME;				/* and quit. */
    }
}
    break;
case 35:
    {				/* EOT, no more files */
    ack();				/* Acknowledge */
    tsecs = gtimer();			/* Get timing for statistics */
    reot();				/* Do EOT things */
    RESUME;				/* and quit */
}
    break;
case 36:
    {				/* Data packet */
    if (cxseen)				/* If file interrupt */
      ack1("X");			/* put "X" in ACK */
    else if (czseen)			/* If file-group interrupt */
      ack1("Z");			/* put "Z" in ACK */
    else if (decode(rdatap,putfil) < 0) { /* Normal case, */
	errpkt("Error writing data");	/*   decode data to file */
	RESUME;				/* Send ACK if data written */
    } else ack();			/* to file OK. */
}
    break;
case 37:
    {			/* End Of File (EOF) Packet */
/*  wslots = 1;				/* Window size back to 1 */
    if (reof(filnam, &iattr) < 0) {	/* Close & dispose of the file */
	errpkt("Can't close file");	/* If problem, send error message */
	RESUME;				/* and quit */
    } else {				/* otherwise */
	ack();				/* acknowledge the EOF packet */
	success = 1;
	BEGIN rfile;			/* and await another file */
    }
}
    break;
case 38:
    {				/* ACK for Send-Init */
    spar(rdatap);			/* set parameters from it */
    bctu = bctr;			/* switch to agreed-upon block check */
    x = sfile(xflg);			/* Send X or F header packet */
    if (x) {				/* If the packet was sent OK */
	resetc();			/* reset per-transaction counters */
	rtimer();			/* reset timers */
	BEGIN ssfile;			/* and switch to receive-file state */
    } else {				/* otherwise send error msg & quit */
	s = xflg ? "Can't execute command" : "Can't open file";
	errpkt(s);
	RESUME;
    }
}
    break;
case 39:
    {				/* ACK for F packet */
    srvptr = srvcmd;			/* Point to string buffer */
    decode(rdatap,putsrv);		/* Decode data field, if any */
    putsrv('\0');			/* Terminate with null */
    if (*srvcmd)			/* If remote name was recorded */
      tlog(F110," stored as",srvcmd,0); /* Record it in transaction log. */
    if (atcapu) {			/* If attributes are to be used */
	if (sattr(xflg) < 0) {		/* set and send them */
	    errpkt("Can't send attributes"); /* if problem, say so */
	    RESUME;			     /* and quit */
	} else BEGIN ssattr;		/* if ok, switch to attribute state */
    } else {
	window(wslotsn);
	if (sdata() < 0) {		/* No attributes, send data */
	    clsif();			/* If not ok, close input file, */
	    seof("");			/* send EOF packet */
	    BEGIN sseof;		/* and switch to EOF state. */
	} else BEGIN ssdata;		/* All ok, switch to send-data state */
    }
}
    break;
case 40:
    {				/* Got ACK to A packet */
    if (rsattr(rdatap) < 0) {		/* Was the file refused? */
	clsif();			/* yes, close it */
	sxeof("D");			/* send EOF with "discard" code */
	BEGIN sseof;			/* switch to send-EOF state */
    } else {
	window(wslotsn);		/* Allocate negotiated window. */
	if (sdata() < 0) {		/* File accepted, send data */
	    clsif();			/* If problem, close input file */
/***	    wslots = 1;			/* Window size back to 1... */
	    seof("");			/* send EOF packet */
	    BEGIN sseof;		/* and switch to send-EOF state. */
	} else {			/* All ok, enter send-data state. */
	    BEGIN ssdata;
	}
    }
}
    break;
case 41:
    {				/* Got ACK to Data packet */
    canned(rdatap);			/* Check if file transfer cancelled */
    if ((sdata() < 0) || cxseen || czseen) { /* Try to send next data */
	clsif();			/* If no more data, close file */
/****	wslots = 1;  ***/		/* Window size back to 1... */
	if (cxseen || czseen)		/* If interrupted */
	  seof("D");			/* send special EOF packet */
	else seof("");			/* Otherwise regular EOF packet */
	BEGIN sseof;			/* And enter send-eof state */
    }
}
    break;
case 42:
    {				/* Got ACK to EOF */
    success = (cxseen == 0 && czseen == 0); /* Set this for IF command */
    cxseen = 0;				/* This goes back to zero. */
    if (gnfile() > 0) {			/* Any more files to send? */
	if (sfile(xflg))		/* Yes, try to send next file header */
	  BEGIN ssfile;			/* if ok, enter send-file state */
	else {				/* otherwise */
	    errpkt("Can't open file");	/* send error message */
	    RESUME;			/* and quit */
	}
    } else {				/* No next file */
	tsecs = gtimer();		/* get statistics timers */
	seot();				/* send EOT packet */
	BEGIN sseot;			/* enter send-eot state */
    }
}
    break;
case 43:
    {				/* Got ACK to EOT */
    RESUME;				/* All done, just quit */
}
    break;
case 44:
    {					/* Got Error packet, in any state */
    ermsg(rdatap);			/* Issue message. */
    success = 0;			/* For IF SUCCESS/FAIL. */
    x = quiet; quiet = 1;		/* Close files silently, */
    clsif(); clsof(1);			/* discarding any output file. */
    tsecs = gtimer();			/* Get timers */
    quiet = x;				/* restore quiet state */
    if (backgrd && !server) fatal("Protocol error");
    RESUME;
}
    break;
case 45:
    { QUIT; }
    break;
case 46:
    {					/* Anything not accounted for above */
    errpkt("Unexpected packet type");	/* Give error message */
    RESUME;				/* and quit */
}
    break;

	    }
    }
}

CHAR tbl[] = {
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 10, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46,  9, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 35, 46, 46, 44, 31, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 32, 46, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 33, 46, 46, 34, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 37, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 36, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 37, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 38, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 39, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 40, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 41, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 42, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 43, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
-1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 
17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 
17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 
17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 
17, 17, 17, 15, 17, 17, 17, 14, 17, 12, 17, 17, 17, 17, 17, 17, 
17, 17, 13,  8, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 
17,  7, 17,  4, 17, 17, 17,  5, 17, 17, 17, 17, 17, 17, 17, 17, 
17, 16,  3,  1, 17, 17,  2, 17,  6, 17, 17, 17, 17, 17, 17, 17, 
-1, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 
29, 29, 29, 18, 19, 20, 21, 29, 23, 29, 29, 29, 22, 29, 29, 29, 
29, 29, 29, 24, 25, 26, 29, 27, 29, 29, 29, 29, 29, 29, 29, 29, 
29,  7, 29,  4, 29, 29, 29,  5, 29, 29, 29, 29, 29, 29, 29, 29, 
29, 28,  3,  1, 29, 29,  2, 29,  6, 29, 29, 29, 29, 29, 29, 29, 
-1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46,  8, 46, 46, 46, 46, 46, 11, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
 0, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46, 46, 46, 44, 31, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 46, 46,  8, 46, 46, 46, 46, 32, 30, 46, 46, 46, 46, 46, 46, 
46,  7, 46,  4, 46, 46, 46,  5, 46, 46, 46, 46, 46, 46, 46, 46, 
46, 45,  3,  1, 46, 46,  2, 46,  6, 46, 46, 46, 46, 46, 46, 46, 
};


/*  P R O T O  --  Protocol entry function  */

proto() {

    extern int sigint();
    int x;

    conint(sigint);			/* Enable console interrupts */

/* Set up the communication line for file transfer. */

    if (local && (speed < 0) && (network == 0)) {
	screen(SCR_EM,0,0l,"Sorry, you must 'set speed' first");
	return;
    }
    x = -1;
    if (ttopen(ttname,&x,mdmtyp) < 0) {
	debug(F111,"failed: proto ttopen local",ttname,local);
	screen(SCR_EM,0,0l,"Can't open line");
	return;
    }
    if (x > -1) local = x;
    debug(F111,"proto ttopen local",ttname,local);

    x = (local && !network) ? speed : -1;
    if (ttpkt(x,flow,parity) < 0) {	/* Put line in packet mode, */
	screen(SCR_EM,0,0l,"Can't condition line");
	return;
    }
    if (sstate == 'x') {		/* If entering server mode, */
	server = 1;			/* set flag, */
	if (!quiet) {
	    if (!local)			/* and issue appropriate message. */
	    	conol(srvtxt);
	    else {
	    	conol("Entering server mode on ");
		conoll(ttname);
	    }
	}
    } else server = 0;
    if (sstate == 'v' && !local && !quiet && cmdlvl == 0)
      conoll("Escape back to your local Kermit and give a SEND command...");
    if (sstate == 's' && !local && !quiet && cmdlvl == 0)
      conoll("Escape back to your local Kermit and give a RECEIVE command...");
    sleep(1);
/*
 The 'wart()' function is generated by the wart program.  It gets a
 character from the input() routine and then based on that character and
 the current state, selects the appropriate action, according to the state
 table above, which is transformed by the wart program into a big case
 statement.  The function is active for one transaction.
*/
    wart();				/* Enter the state table switcher. */
    
    if (server) {			/* Back from packet protocol. */
	server = 0;
    	if (!quiet)  			/* Give appropriate message */
	    conoll("C-Kermit server done");
    }
    ttres();				/* Reset the terminal */
    screen(SCR_TC,0,0l,"");		/* Transaction complete */
}
